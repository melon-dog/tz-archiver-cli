# GENERATED BY CHAT GPT 5, Don't be afraid to clean this up if necessary.

# tzkt_typed_client.py
from __future__ import annotations
from dataclasses import dataclass, field, asdict
import time
from typing import Any, Dict, List, Optional
import requests
import random

# ---------- Types / Dataclasses (mirror of TS types) ----------


@dataclass
class Dimensions:
    unit: Optional[str] = None
    value: Optional[str] = None


@dataclass
class DataRate:
    unit: Optional[str] = None
    value: Optional[str] = None


@dataclass
class Format:
    uri: Optional[str] = None
    fileName: Optional[str] = None
    fileSize: Optional[str] = None
    mimeType: Optional[str] = None
    dimensions: Optional[Dimensions] = None
    dataRate: Optional[DataRate] = None
    duration: Optional[str] = None


@dataclass
class Gpu:
    # empty placeholder as per TS
    pass


@dataclass
class Hardware:
    gpu: Optional[Gpu] = None


@dataclass
class Viewport:
    width: Optional[str] = None
    height: Optional[str] = None
    deviceScaleFactor: Optional[str] = None


@dataclass
class Resolution:
    x: Optional[str] = None
    y: Optional[str] = None


@dataclass
class Software:
    name: Optional[str] = None
    version: Optional[str] = None
    viewport: Optional[Viewport] = None
    resolution: Optional[Resolution] = None


@dataclass
class Preservation:
    hardware: Optional[List[Hardware]] = None
    software: Optional[List[Software]] = None


@dataclass
class Accessibility:
    hazards: Optional[List[str]] = None


@dataclass
class Shares:
    # dynamic mapping of string keys to string values
    shares: Dict[str, str] = field(default_factory=dict)


@dataclass
class Royalties:
    shares: Optional[Dict[str, str]] = None
    decimals: Optional[str] = None


@dataclass
class Metadata:
    date: Optional[str] = None
    name: Optional[str] = None
    tags: Optional[List[str]] = None
    image: Optional[str] = None
    minter: Optional[str] = None
    rights: Optional[str] = None
    symbol: Optional[str] = None
    formats: Optional[List[Format]] = None
    creators: Optional[List[str]] = None
    decimals: Optional[str] = None
    royalties: Optional[Royalties] = None
    attributes: Any = None
    displayUri: Optional[str] = None
    artifactUri: Optional[str] = None
    description: Optional[str] = None
    mintingTool: Optional[str] = None
    thumbnailUri: Optional[str] = None
    authors: Optional[List[str]] = None
    mimeType: Optional[str] = None
    authoraddress: Optional[List[str]] = None
    artists: Optional[List[str]] = None
    minterkey: Optional[str] = None
    isBooleanAmount: Optional[bool] = None
    shouldPreferSymbol: Optional[bool] = None
    language: Optional[str] = None
    accessibility: Optional[Accessibility] = None
    preservation: Optional[Preservation] = None
    editions: Optional[str] = None
    mintingToolVersion: Optional[str] = None
    contentRating: Optional[str] = None
    version: Optional[str] = None
    generatorUri: Optional[str] = None
    iterationHash: Optional[str] = None
    snippetVersion: Optional[str] = None
    authenticityHash: Optional[str] = None


@dataclass
class Contract:
    alias: Optional[str] = None
    address: Optional[str] = None


@dataclass
class FirstMinter:
    alias: Optional[str] = None
    address: Optional[str] = None


@dataclass
class Token:
    id: Optional[int] = None  # bigint -> int in python
    contract: Optional[Contract] = None
    tokenId: Optional[str] = None
    standard: Optional[str] = None
    firstMinter: Optional[FirstMinter] = None
    firstLevel: Optional[int] = None  # bigint -> int
    firstTime: Optional[str] = None
    lastLevel: Optional[int] = None  # bigint -> int
    lastTime: Optional[str] = None
    transfersCount: Optional[int] = None  # bigint -> int
    balancesCount: Optional[int] = None  # bigint -> int
    holdersCount: Optional[int] = None  # bigint -> int
    totalMinted: Optional[str] = None
    totalBurned: Optional[str] = None
    totalSupply: Optional[str] = None
    metadata: Optional[Metadata] = None


Tokens = List[Token]

# ---------- Helpers to parse JSON -> dataclasses ----------


def _safe_int(value: Any) -> Optional[int]:
    if value is None:
        return None
    try:
        # some responses may already be int, some may be string
        return int(value)
    except (ValueError, TypeError):
        return None


def _parse_dimensions(d: Optional[Dict[str, Any]]) -> Optional[Dimensions]:
    if not d:
        return None
    return Dimensions(unit=d.get("unit"), value=d.get("value"))


def _parse_datarate(d: Optional[Dict[str, Any]]) -> Optional[DataRate]:
    if not d:
        return None
    return DataRate(unit=d.get("unit"), value=d.get("value"))


def _parse_format(f: Optional[Dict[str, Any]]) -> Optional[Format]:
    if not f:
        return None
    return Format(
        uri=f.get("uri"),
        fileName=f.get("fileName"),
        fileSize=f.get("fileSize"),
        mimeType=f.get("mimeType"),
        dimensions=_parse_dimensions(f.get("dimensions")),
        dataRate=_parse_datarate(f.get("dataRate")),
        duration=f.get("duration"),
    )


def _parse_gpu(_d: Any) -> Optional[Gpu]:
    # placeholder: GPU structure undefined in TS; keep as empty placeholder
    if _d is None:
        return None
    return Gpu()


def _parse_hardware(hd: Optional[Dict[str, Any]]) -> Optional[Hardware]:
    if not hd:
        return None
    return Hardware(gpu=_parse_gpu(hd.get("gpu")))


def _parse_viewport(v: Optional[Dict[str, Any]]) -> Optional[Viewport]:
    if not v:
        return None
    return Viewport(
        width=v.get("width"),
        height=v.get("height"),
        deviceScaleFactor=v.get("deviceScaleFactor"),
    )


def _parse_resolution(r: Optional[Dict[str, Any]]) -> Optional[Resolution]:
    if not r:
        return None
    return Resolution(x=r.get("x"), y=r.get("y"))


def _parse_software(s: Optional[Dict[str, Any]]) -> Optional[Software]:
    if not s:
        return None
    return Software(
        name=s.get("name"),
        version=s.get("version"),
        viewport=_parse_viewport(s.get("viewport")),
        resolution=_parse_resolution(s.get("resolution")),
    )


def _parse_preservation(p: Optional[Dict[str, Any]]) -> Optional[Preservation]:
    if not p:
        return None
    hardware_list = p.get("hardware")
    software_list = p.get("software")
    hw = None
    sw = None
    if hardware_list and isinstance(hardware_list, list):
        hw = [_parse_hardware(h) for h in hardware_list if h is not None]
    if software_list and isinstance(software_list, list):
        sw = [_parse_software(s) for s in software_list if s is not None]
    return Preservation(hardware=hw, software=sw)


def _parse_accessibility(a: Optional[Dict[str, Any]]) -> Optional[Accessibility]:
    if not a:
        return None
    return Accessibility(hazards=a.get("hazards"))


def _parse_royalties(r: Optional[Dict[str, Any]]) -> Optional[Royalties]:
    if not r:
        return None
    return Royalties(shares=r.get("shares"), decimals=r.get("decimals"))


def _parse_metadata(m: Optional[Dict[str, Any]]) -> Optional[Metadata]:
    if not m:
        return None
    formats = None
    if m.get("formats") and isinstance(m.get("formats"), list):
        formats = [_parse_format(f) for f in m.get("formats") if f is not None]
    return Metadata(
        date=m.get("date"),
        name=m.get("name"),
        tags=m.get("tags"),
        image=m.get("image"),
        minter=m.get("minter"),
        rights=m.get("rights"),
        symbol=m.get("symbol"),
        formats=formats,
        creators=m.get("creators"),
        decimals=m.get("decimals"),
        royalties=_parse_royalties(m.get("royalties")),
        attributes=m.get("attributes"),
        displayUri=m.get("displayUri"),
        artifactUri=m.get("artifactUri"),
        description=m.get("description"),
        mintingTool=m.get("mintingTool"),
        thumbnailUri=m.get("thumbnailUri"),
        authors=m.get("authors"),
        mimeType=m.get("mimeType"),
        authoraddress=m.get("authoraddress"),
        artists=m.get("artists"),
        minterkey=m.get("minterkey"),
        isBooleanAmount=m.get("isBooleanAmount"),
        shouldPreferSymbol=m.get("shouldPreferSymbol"),
        language=m.get("language"),
        accessibility=_parse_accessibility(m.get("accessibility")),
        preservation=_parse_preservation(m.get("preservation")),
        editions=m.get("editions"),
        mintingToolVersion=m.get("mintingToolVersion"),
        contentRating=m.get("contentRating"),
        version=m.get("version"),
        generatorUri=m.get("generatorUri"),
        iterationHash=m.get("iterationHash"),
        snippetVersion=m.get("snippetVersion"),
        authenticityHash=m.get("authenticityHash"),
    )


def _parse_contract(c: Optional[Dict[str, Any]]) -> Optional[Contract]:
    if not c:
        return None
    return Contract(alias=c.get("alias"), address=c.get("address"))


def _parse_first_minter(fm: Optional[Dict[str, Any]]) -> Optional[FirstMinter]:
    if not fm:
        return None
    return FirstMinter(alias=fm.get("alias"), address=fm.get("address"))


def _parse_token(t: Dict[str, Any]) -> Token:
    return Token(
        id=_safe_int(t.get("id")),
        contract=_parse_contract(t.get("contract")),
        tokenId=t.get("tokenId"),
        standard=t.get("standard"),
        firstMinter=_parse_first_minter(t.get("firstMinter")),
        firstLevel=_safe_int(t.get("firstLevel")),
        firstTime=t.get("firstTime"),
        lastLevel=_safe_int(t.get("lastLevel")),
        lastTime=t.get("lastTime"),
        transfersCount=_safe_int(t.get("transfersCount")),
        balancesCount=_safe_int(t.get("balancesCount")),
        holdersCount=_safe_int(t.get("holdersCount")),
        totalMinted=t.get("totalMinted"),
        totalBurned=t.get("totalBurned"),
        totalSupply=t.get("totalSupply"),
        metadata=_parse_metadata(t.get("metadata")),
    )


def _parse_tokens_list(data: Any) -> Optional[Tokens]:
    if not isinstance(data, list):
        return None
    parsed: Tokens = []
    for item in data:
        try:
            parsed.append(_parse_token(item))
        except Exception:
            # skip malformed items but continue
            continue
    return parsed


# ---------- HTTP utilities ----------

API_MAX = 10_000
HARDCODED_CURRENT_TOKENS_WITH_ARTIFACTS = 6_000_000


def api_call(url: str, timeout: int = 15) -> requests.Response:
    time.sleep(0.1)  # to avoid rate limits
    return requests.get(url, timeout=timeout)


# ---------- Public API functions (same semantics as your TS) ----------


def balances(holder: str, limit: int, offset: int) -> Optional[Tokens]:
    results: List[Token] = []
    current_offset = offset
    remaining = limit
    try:
        while remaining > 0:
            batch_limit = min(API_MAX, remaining)
            url = (
                f"https://api.tzkt.io/v1/tokens/balances"
                f"?account={holder}&balance.ne=0&limit={batch_limit}&offset={current_offset}&select=token"
            )
            resp = api_call(url)
            resp.raise_for_status()
            data = resp.json()
            tokens = _parse_tokens_list(data)
            if not tokens:
                break
            results.extend(tokens)
            if len(data) < batch_limit:
                break
            current_offset += len(data)
            remaining -= len(data)
        return results
    except Exception:
        return None


def mints(
    creator: str, min_timestamp: Optional[str], limit: int, offset: int
) -> Optional[Tokens]:
    results: List[Token] = []
    current_offset = offset
    remaining = limit
    try:
        while remaining > 0:
            batch_limit = min(API_MAX, remaining)
            time_filter = f"&firstTime.ge={min_timestamp}" if min_timestamp else ""
            url = (
                f"https://api.tzkt.io/v1/tokens"
                f"?firstMinter={creator}{time_filter}&limit={batch_limit}&offset={current_offset}&metadata.artifactUri.null=false"
            )
            resp = api_call(url)
            resp.raise_for_status()
            data = resp.json()
            tokens = _parse_tokens_list(data)
            if not tokens:
                break
            results.extend(tokens)
            if len(data) < batch_limit:
                break
            current_offset += len(data)
            remaining -= len(data)
        return results
    except Exception:
        return None


def random_tokens(limit: int) -> Optional[Tokens]:
    results: List[Token] = []
    current_offset = random.randint(
        0, max(0, HARDCODED_CURRENT_TOKENS_WITH_ARTIFACTS - 1)
    )
    remaining = limit
    try:
        while remaining > 0:
            batch_limit = min(API_MAX, remaining)
            url = (
                f"https://api.tzkt.io/v1/tokens"
                f"?limit={batch_limit}&offset={current_offset}&metadata.artifactUri.null=false"
            )
            resp = api_call(url)
            resp.raise_for_status()
            data = resp.json()
            tokens = _parse_tokens_list(data)
            if not tokens:
                break
            results.extend(tokens)
            if len(data) < batch_limit:
                break
            current_offset += len(data)
            remaining -= len(data)
        return results
    except Exception:
        return None


def contract_tokens(contract: str, limit: int, offset: int) -> Optional[Tokens]:
    results: List[Token] = []
    current_offset = offset
    remaining = limit
    try:
        while remaining > 0:
            batch_limit = min(API_MAX, remaining)
            url = (
                f"https://api.tzkt.io/v1/tokens"
                f"?contract={contract}&limit={batch_limit}&offset={current_offset}&metadata.artifactUri.null=false"
            )
            resp = api_call(url)
            resp.raise_for_status()
            data = resp.json()
            tokens = _parse_tokens_list(data)
            if not tokens:
                break
            results.extend(tokens)
            if len(data) < batch_limit:
                break
            current_offset += len(data)
            remaining -= len(data)
        return results
    except Exception:
        return None


def token(contract: str, token_id: str) -> Optional[Token]:
    try:
        url = f"https://api.tzkt.io/v1/tokens?contract={contract}&tokenId={token_id}&limit=1"
        resp = api_call(url)
        resp.raise_for_status()
        data = resp.json()
        tokens = _parse_tokens_list(data)
        if tokens and len(tokens) > 0:
            return tokens[0]
        return None
    except Exception:
        return None


def block_count() -> Optional[int]:
    try:
        url = "https://api.tzkt.io/v1/blocks/count"
        resp = api_call(url)
        resp.raise_for_status()
        txt = resp.text
        return int(txt)
    except Exception:
        return None


def tokens(limit: int, offset: int) -> Optional[Tokens]:
    """
    Fetch tokens using a deterministic offset for systematic coverage.

    Args:
        limit: Maximum number of tokens to fetch
        offset: Specific offset position in the token space

    Returns:
        List of tokens or None if error
    """
    try:
        url = f"https://api.tzkt.io/v1/tokens?limit={limit}&offset={offset}&metadata.artifactUri.null=false"

        # Basic rate limiting for TzKT
        time.sleep(0.1)

        resp = api_call(url)
        resp.raise_for_status()
        data = resp.json()

        return _parse_tokens_list(data)

    except Exception as e:
        # Optional: log error details if needed
        return None
